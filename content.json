{"meta":{"title":"Just Fucking Do It!!!","subtitle":null,"description":"Time is Short. Just Do It!!!","author":"Hyogeun Kim","url":"https://ultrasound.github.io"},"pages":[],"posts":[{"title":"built-in functions","slug":"built-in-functions","date":"2017-12-16T07:25:31.148Z","updated":"2017-12-14T06:08:24.000Z","comments":true,"path":"2017/12/16/built-in-functions/","link":"","permalink":"https://ultrasound.github.io2017/12/16/built-in-functions/","excerpt":"","text":"¶abs 어떤 숫자를 입력으로 받았을 때 그, 숫자의 절대값을 돌려줌. ¶all all(x) 반복 가능한(iterable) 자료형 x를 입력 인수로 받아 이 x가 모두 참이면 True, 거짓이 하나라도 있으면 False를 리턴. ¶any any(x) x 중 하나라도 참이 있을 경우 True를 리턴, x가 모두 거짓일 경우 False를 리턴, all(x)의 반대 경우. ¶chr chr(i)는 ASCII 코드값을 입력받아 그 코드에 해당하는 문자를 출력. ¶dir 객제가 자체적으로 가지고 있는 변수나 함수를 보여줌. ¶divmod divmod(a, b)는 2개의 숫자를 입력받아 a를 b로 나눈 몫과 나머지를 튜플 형태로 리턴. ¶enumerate 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 리턴. for 문처럼 반복되는 구간에서 객체가 현재 어느 위치에 있는지 알려주는 인덱스 값이 필요할때 enumerate 함수를 사용하면 유용. ¶eval eval(expression)은 실행 가능한 문자열(1+2, ‘hi’ + ‘a’ 같은 것)을 입력으로 받아 문자열을 실행한 결과값을 리턴. 보통 eval은 입력받은 문자열로 파이썬 함수나 클래스를 동적으로 실행하고 싶은 경우에 사용. ¶filter filter 함수는 첫 번째 인수로 함수 이름을, 두 번째 인수로 그 함수에 차례로 들어갈 반복 가능한 자료형을 받는다. 그리고 두 번째 인수인 반복 가능한 자료형 요소들이 첫 번째 인수인 함수에 입력되었을 때 리턴값이 참인 것만 묶어서 돌려줌. ¶hex 정수값을 입력받아 16진수로 변환하여 리턴. ¶id 객체를 입력받아 객체의 고유 주소값(레퍼런스)을 리턴. ¶input 사용자 입력을 받는 함수. ¶int 문자열 형태의 숫자나 소수점이 있는 숫자 등을 정수 형태로 리턴하는 함수로, 정수를 입력으로 받으면 그대로 리턴. ¶isinstance isinstance(object, class)는 첫 번째 인수로 인스턴스, 두 번째 인수로 클래스 이름을 받음. 입력으로 받은 인스턴스가 그 클래스의 인스턴스인지를 판단하여 참이면 True, 거짓이면 False를 리턴. ¶lambda 함수를 생성할 때 사용하는 예약어. def와 동일한 역할을 한다. 보통 함수를 한줄로 간결하게 만들 때 사용. def를 사용해야 할 정도로 복잡하지 않거나 def를 사용할 수 없는 곳에 주로 쓰임. lambda 인수1, 인수2, ...: 인수를 이용한 표현식 12sum = lambda a, b: a+bsum(3, 4) lambda는 def를 사용할 수 없는 곳에도 사용할 수 있다. 12345myList = [lambda a, b:a+b, lambda a, b:a*b]myListmyList[0]myList[0](3,4)myList[1](3,4) ¶len len(s) 입력값 s의 길이(요소의 전체 개수)를 리턴하는 함수. ¶list 반복 가능한 자료형를 입력받아 리스트로 만들어 리턴하는 함수. list 함수에 리스트를 입력으로 주면 똑같은 리스트를 복사하여 돌려줌. ¶map map(f, iterable)은 함수(f)와 반복 가능한(iterable) 자료형을 입력으로 받음. map은 입력받은 자료형의 각 요소가 함수 f에 의해 수행된 결과를 묶어서 리턴하는 함수이다. 123456789# two_times.pydef two_times(numberList): result = [] for number in numberList: result.append(number*2) return resultresult = two_times([1, 2, 3, 4])print(result) 위의 예제는 map 함수를 이용하여 다음과 같이 바꿀 수 있음. 12def two_times(x): returen x*2list(map(two_times, [1, 2, 3, 4])) lambda를 사용하여 다음처럼 간략하게 만들 수 있음. 1list(map(lambda a: a*2, [1, 2, 3, 4])) 123def plus_one(x): return x+1print(list(map(plus_one, [1, 2, 3, 4, 5]))) ¶max max(iterable)는 인수로 반복 가능한 자료형을 입력받아 그 최대값을 리턴. ¶min min(iterable)은 max와 반대로, 인수로 반복 가능한 자료형을 입력받아 그 최소값을 리턴. ¶oct 정수 형태의 숫자를 8진수 문자열로 바꾸어 리턴. ¶open open(filename, [mode])은 파일 이름과 읽기 방법을 입력받아 파일 객체를 리턴하는 함수. 읽기 방법(mode)이 생략되면 기본값인 읽기 전용 모드(r)로 파일 객체를 만들어 리턴. mode 설명 w 쓰기 모드로 파일 열기 r 읽기 모드로 파일 열기 a 추가 모드로 파일 열기 b 바이너리 모드로 파일 열기 b는 w, r, a와 함께 사용됨. 12f = open(&quot;binary_file&quot;, &quot;rb&quot;)fappend = open(&quot;append_mode.txt&quot;, &apos;a&apos;) ¶ord 문자의 아스키 코드값을 리턴 chr 함수와 반대 ¶pow pow(x, y)는 x의 y 제곱한 결과값을 리턴 ¶range range([start,] stop [,step])는 for문과 함께 자주 사용되는 함수 입력받은 숫자에 해당되는 범위의 값알 반복 가능한 객체로 만들어 리턴. 123list(range(5))list(range(5, 10))list(range(1, 10, 2)) ¶sorted sorted(iterable) 함수는 입력값을 정렬한 후 그 결과를 리스트로 리턴 리스트 자료형에도 sort라는 함수가 있다. 하지만 리스트 자료형의 sort 함수는 리스트 객체 그 자체를 정렬할 뿐 정렬된 결과를 리턴하지 않음. ¶str str(object)은 문자열 형태로 객체를 변환하여 리턴하는 함수 ¶tuple tuple(iterable)은 반복 가능한 자료형을 입력받아 튜플 형태로 바꾸어 리턴하는 함수. 만약 튜플이 입력으로 들어오면 그대로 리턴. ¶type type(object)은 입력값의 자료형이 무엇인지 알려주는 함수 ¶zip zip(iterable*)은 동일한 개수로 이루어진 자료형을 묶어 주는 함수 1234list(zip([1, 2, 3], [4, 5, 6]))list(zip([1, 2, 3], [4, 5, 6], [7, 8, 9]))list(zip(\"abc\", \"def\"))[('a', 'd'), ('b', 'e'), ('c', 'f')] ¶Link https://wikidocs.net/32","categories":[{"name":"python","slug":"python","permalink":"https://ultrasound.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ultrasound.github.io/tags/python/"},{"name":"built-in functions","slug":"built-in-functions","permalink":"https://ultrasound.github.io/tags/built-in-functions/"}]},{"title":"kiwoom TR and FID","slug":"kiwoom-tr-and-fid","date":"2017-11-25T13:25:00.000Z","updated":"2017-11-25T13:33:41.113Z","comments":true,"path":"2017/11/25/kiwoom-tr-and-fid/","link":"","permalink":"https://ultrasound.github.io2017/11/25/kiwoom-tr-and-fid/","excerpt":"","text":"¶TR ¶opw00001 예수금 정보를 얻을 수 있음. ¶opw00018 잔고 및 보유종목 현황에 관련된 대부분의 데이터를 얻을 수 있음. 예수금 정보는 얻을 수 없음. ¶opt10001 주식 기본 정보 요청 시가, 고가, 저가, 상한가, 하한가, 현재가, 거래량 ¶opt10081 일봉 데이터를 요청 ¶FID ¶Link 파이썬으로 배우는 알고리즘 트레이딩","categories":[{"name":"Auto Trading System","slug":"auto-trading-system","permalink":"https://ultrasound.github.io/categories/auto-trading-system/"}],"tags":[{"name":"kiwoom","slug":"kiwoom","permalink":"https://ultrasound.github.io/tags/kiwoom/"},{"name":"TR","slug":"tr","permalink":"https://ultrasound.github.io/tags/tr/"},{"name":"FID","slug":"fid","permalink":"https://ultrasound.github.io/tags/fid/"}]},{"title":"OpenAPI+ basic API","slug":"openapi-basic-api","date":"2017-11-21T06:30:53.508Z","updated":"2017-11-13T00:49:43.000Z","comments":true,"path":"2017/11/21/openapi-basic-api/","link":"","permalink":"https://ultrasound.github.io2017/11/21/openapi-basic-api/","excerpt":"","text":"¶Open API+ 로그인하기 파이썬에서 OpenAPI+를 사용하려면 PyQt를 사용하는 것이 가장 편리한 방법. 전체코드1234567891011121314151617181920212223242526272829303132333435import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QAxContainer import *class MyWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"PyStock\") self.setGeometry(300, 300, 300, 150) self.kiwoom = QAxWidget(\"KHOPENAPI.KHOpenAPICtrl.1\") btn1 = QPushButton(\"Login\", self) btn1.move(20, 20) btn1.clicked.connect(self.btn1_clicked) btn2 = QPushButton(\"Check state\", self) btn2.move(20, 70) btn2.clicked.connect(self.btn2_clicked) def btn1_clicked(self): ret = self.kiwoom.dynamicCall(\"CommConnect()\") def btn2_clicked(self): if self.kiwoom.dynamicCall(\"GetConnectState()\") == 0: self.statusBar().showMessage(\"Not connected\") else: self.statusBar().showMessage(\"Connected\")if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() 파이썬에서 키움증권의 클래스를 사용하려면 PyQt의 QAxWidget 클래스를 사용하여 인스턴스를 생성해야 함. 키움증권이 제공하는 클래스는 각각 고유의 CLSID 또는 ProgID를 가지는데 해당 값을 QAxWidget 클래스의 생성자로 넘겨주면 인스턴스가 생성됨. 키움증권의 개발 가이드를 참조하면 CLSID는 {A1574A0D-6BFA-4BD7-9020-DED88711818D} 임을 알 수 있고, 이를 윈도우 레지스트리 편집기를 통해 검색하면 ProgID는 아래와 같이 `‘KHOPENAPI.KHOpenAPICtrl.1’ 임을 알 수 있음. CLSID는 10진수로 구성되어 있어 조금 복작하기 때문에 파이썬에서 증권사 API가 제공하는 클래스의 인스턴스를 생성할 때는 보통 문자열로 된 ProgID를 사용하는 것이 편리. 키움증권이 제공하는 클래스를 사용하기 위해 ProgID를 QAxWidget 클래스의 생성자로 전달하여 인스턴스를 생성. 키움이 제공하는 클래스 사용1234class MyWindow(QMainWindow): def __init__(self): # 코드 생략 self.kiwoom = QAxWidget(\"KHOPENAPI.KHOpenAPICtrl.1\") self.kiwoom은 QAxWidget 클래스의 인스턴스인데 QAxWidget 클래스는 아래와 같이 QWidget과 QAxBase라는 클래스를 상속 받음. OpenAPI+는 로그인 윈도우를 실행하는 CommConnect 메서드를 제공. 즉, 인스턴스를 통해 CommConnect 메서드를 호출하기만 하면 로그인을 위한 윈도우가 자동으로 실행됨. 키움증권의 OpenAPI+는 OCX 방식으로 개발되었기 때문에 파이썬에서 메서드를 호출하는 방식도 COM 방식과는 다름. COM 방식에서는 인스턴스를 통해 메서드를 호출했던 것과 달리 OCX 방식에서는 QAxBase 클래스의 dynamicCall 메서드를 사용하여 원하는 메서드를 호출할 수 있음. 정리해보면 OpenAPI+가 제공하는 메서드를 사용하기 위해서는 self.kiwoom 객체를 통해 dynamicCall 메서드를 호출해야 함. 이때 dynamicCall 메서드의 인자로 호출하려는 메서드를 넘겨줌. call CommConnect1self.kiwoom.dynamicCall(\"CommConnect()\") 서버 접속 상태를 확인 하기 위해 GetConnectState 메서드를 호출한 후 메서드의 리턴 값을 확인. ¶로그인 이벤트 처리하기 OpenAPI+의 CommConnect 메서드를 통해 키움증권 서버에 로그인을 시도하면 키움증권 서버는 아래와 같이 OnEventConnect라는 이벤트를 발생. 따라서 프로그램이 OnEventConnect 이벤트를 처리한다면 GetConnectState 메서드를 사용하지 않고도 로그인 상태 확인 가능. 이벤트 처리를 통한 로그인 여부 확인1234567891011121314151617181920212223242526272829import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QAxContainer import *class MyWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"PyStock\") self.setGeometry(300, 300, 300, 150) self.kiwoom = QAxWidget(\"KHOPENAPI.KHOpenAPICtrl.1\") self.kiwoom.dynamicCall(\"CommConnect()\") self.text_edit = QTextEdit(self) self.text_edit.setGeometry(10, 60, 280, 80) self.text_edit.setEnabled(False) self.kiwoom.OnEventConnect.connect(self.event_connect) def event_connect(self, err_code): if err_code == 0: self.text_edit.append(\"로그인 성공\")if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() OpenAPI+는 통신 연결 상태가 변경될 때 OnEventConnect라는 이벤트가 발생. 발생된 OnEventConnect 이벤트를 처리하기 위해 MyWindow 클래스에 event_connect라는 이름의 메서드를 구현하고 이벤트와 이벤트 처리 메서드를 연결 시키면 이벤트(OnEventConnect) 발생 시 자동으로 이벤트 처리 메서드 (self.event_connect)가 호출 됨. event_connect 메서드는 메서드의 인자로 넘어오는 err_code 값을 확인. QTextEdit 객체에 문자열을 추가하기 위해 append라는 메서드를 사용. 참고로 이 append는 파이썬 리스트의 append 메서드와 전혀 관련 없음. 이벤트와 이벤트 처리 메서드의 연결은 connect 메서드를 사용. ¶기본 정보 요청하기 TR(Transaction) - 서버로 부터 데이터를 주고받는 행위 아래 그림은 KOA Studio를 통해 확인한 OpenAPI+의 TR 목록 각 TR의 기능을 살펴보고 원하는 기능을 제공하는 TR을 사용하여 데이터를 서버에 요청한 후 전송된 값을 받으면 됨. 아래는 opt1001 TR를 사용하여 주식 종목의 기본적인 정보를 얻어오는 프로그램의 모습 PyQt를 사용하여 UI를 구성하는 코드 구현 사용된 PyQt 위젯 리스트 클래스 용도 QLabel 간단한 텍스트 나 이미지 출력(‘종목코드:’ 출력) QLineEdit 간단한 사용자 입력 처리 QPushButton 버튼 생성(‘조회’ 버튼 생성) QTextEdit 메시지 출력 (실행결과 메시지) QLabel은 텍스트나 이미지를 출력하는 데 사용. 만약 텍스트를 출력한다면 생성자의 첫 번째 인자로 출력될 문자열을 넘겨주면 됨. 두 번째 인자에는 부모 위젯을 지정. 아래 전체 코드에서 QLable은 QMainWindow안에 위치하므로 부모 위젯으로 self를 지정. label = QLabel('종목코드: ', self) UI 구성 코드123456789101112131415161718192021222324252627282930import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QAxContainer import *class MyWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\"PyStock\") self.setGeometry(300, 300, 300, 150) label = QLabel('종목코드: ', self) label.move(20, 20) self.code_edit = QLineEdit(self) self.code_edit.move(80, 20) self.code_edit.setText(\"039490\") btn1 = QPushButton(\"조회\", self) btn1.move(190, 20) self.text_edit = QTextEdit(self) self.text_edit.setGeometry(10, 60, 280, 80) self.text_edit.setEnabled(False)if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() 123456789101112131415161718192021222324252627282930313233343536373839404142434445import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QAxContainer import *class MyWindow(QMainWindow): def __init__(self): super().__init__() # Kiwoom Login self.kiwoom = QAxWidget(\"KHOPENAPI.KHOpenAPICtrl.1\") self.kiwoom.dynamicCall(\"CommConnect()\") self.kiwoom.OnEventConnect.connect(self.event_connect) self.setWindowTitle(\"PyStock\") self.setGeometry(300, 300, 300, 150) label = QLabel('종목코드: ', self) label.move(20, 20) self.code_edit = QLineEdit(self) self.code_edit.move(80, 20) self.code_edit.setText(\"039490\") btn1 = QPushButton(\"조회\", self) btn1.move(190, 20) btn1.clicked.connect(self.btn1_clicked) self.text_edit = QTextEdit(self) self.text_edit.setGeometry(10, 60, 280, 80) self.text_edit.setEnabled(False) def event_connect(self, err_code): if err_code == 0: self.text_edit.append(\"로그인 성공\") def btn1_clicked(self): code = self.code_edit.text() self.text_edit.append(\"종목코드: \" + code)if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() opt10001 TR를 통해 기본 정보를 요청하는 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QAxContainer import *class MyWindow(QMainWindow): def __init__(self): super().__init__() # Kiwoom Login self.kiwoom = QAxWidget(\"KHOPENAPI.KHOpenAPICtrl.1\") self.kiwoom.dynamicCall(\"CommConnect()\") # OpenAPI+ Event self.kiwoom.OnEventConnect.connect(self.event_connect) self.kiwoom.OnReceiveTrData.connect(self.receive_trdata) self.setWindowTitle(\"PyStock\") self.setGeometry(300, 300, 300, 150) label = QLabel('종목코드: ', self) label.move(20, 20) self.code_edit = QLineEdit(self) self.code_edit.move(80, 20) self.code_edit.setText(\"039490\") btn1 = QPushButton(\"조회\", self) btn1.move(190, 20) btn1.clicked.connect(self.btn1_clicked) self.text_edit = QTextEdit(self) self.text_edit.setGeometry(10, 60, 280, 80) self.text_edit.setEnabled(False) def event_connect(self, err_code): if err_code == 0: self.text_edit.append(\"로그인 성공\") def btn1_clicked(self): code = self.code_edit.text() self.text_edit.append(\"종목코드: \" + code) # SetInputValue self.kiwoom.dynamicCall(\"SetInputValue(QString, QString)\", \"종목코드\", code) # CommRqData self.kiwoom.dynamicCall(\"CommRqData(QString, QString, int, QString)\", \"opt10001_req\", \"opt10001\", 0, \"0101\") def receive_trdata(self, screen_no, rqname, trcode, recordname, prev_next, data_len, err_code, msg1, msg2): if rqname == \"opt10001_req\": name = self.kiwoom.dynamicCall(\"CommGetData(QString, QString, QString, int, QString)\", trcode, \"\", rqname, 0, \"종목명\") volume = self.kiwoom.dynamicCall(\"CommGetData(QString, QString, QString, int, QString)\", trcode, \"\", rqname, 0, \"거래량\") self.text_edit.append(\"종목명: \" + name.strip()) self.text_edit.append(\"거래량: \" + volume.strip())if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() SetInputValue 메서드를 사용하여 TR 입력 값을 설정. CommRqData 메서드를 사용하여 TR을 서버로 송신. 서버로부터 이벤트가 발생할 때까지 이벤트 루프를 사용하여 대기. CommGetData 메서드를 사용하여 수신 데이터를 가져옴. C++ 코드에서는 먼저 SetInputValue 메서드를 호출하여 종목코드라는 문자열과 실제 종목 코드 값(예: 039490)을 입력. 그다음 CommRqData 메서드를 호출하여 TR를 서버에 전송 파이썬 코드에서는 아래와 같이 구현. 123456789def btn1_clicked(self): code = self.code_edit.text() self.text_edit.append(\"종목코드: \" + code) # SetInputValue self.kiwoom.dynamicCall(\"SetInputValue(QString, QString)\", \"종목코드\", code) # CommRqData self.kiwoom.dynamicCall(\"CommRqData(QString, QString, int, QString)\", \"opt10001_req\", \"opt10001\", 0, \"0101\") QLineEdit 위젯을 통해 입력받은 종목 코드를 'SetInputValue` 메서드의 두 번째 인자로 넘겨주는 것을 확인. TR 구성이 완료됐다면 CommRqData 메서드를 사용하여 TR을 서버로 송신. CommRqData의 첫 번째 인자는 사용자가 TR을 구분하기 위한 용도. 두 번째 인자는 요청하는 TR 이름으로 opt10001을 입력. 세 번째 인자는 단순 조회 TR일 때는 0을 입력. 네 번째 인자는 4자리의 화면 번호. TR을 서버로 송신했으므로 OnReceiveTrData라는 이벤트를 처리할 메서드를 구현하고 이를 이벤트와 연결. OnReceiveTrData 이벤트가 발생했다는 것은 서버로부터 데이터를 전달 받았음을 의미하므로 OnReceiveTrData 메서드에서 CommGetData 메서드를 호출하여 데이터를 얻음. 아래와 같이 이벤트와 이벤트 처리용 메서드를 연결 1234567class MyWindow(QMainWindow): def __init__(self): super().__init__() # 생략 # OpenAPI+ Event self.kiwoom.OnReceiveTrData.connect(self.receive_trdata) ¶계좌 정보 얻어 오기 GetLoginInfo 메서드를 사용하면 계좌 개수, 계좌 번호, 사용자 ID, 사용자명등의 정보를 얻어올 수 있음. 계좌 정보 얻어 오기123456789101112131415161718192021222324252627282930313233343536373839import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QAxContainer import *class MyWindow(QMainWindow): def __init__(self): super().__init__() # Kiwoom Login self.kiwoom = QAxWidget(\"KHOPENAPI.KHOpenAPICtrl.1\") self.kiwoom.dynamicCall(\"CommConnect()\") # OpenAPI+ Event self.kiwoom.OnEventConnect.connect(self.event_connect) self.setWindowTitle(\"계좌 정보\") self.setGeometry(300, 300, 300, 150) btn1 = QPushButton(\"계좌 얻기\", self) btn1.move(190, 20) btn1.clicked.connect(self.btn1_clicked) self.text_edit = QTextEdit(self) self.text_edit.setGeometry(10, 60, 280, 80) def btn1_clicked(self): account_num = self.kiwoom.dynamicCall(\"GetLoginInfo(QString)\", [\"ACCNO\"]) self.text_edit.append(\"계좌번호: \" + account_num.rstrip(';')) def event_connect(self, err_code): if err_code == 0: self.text_edit.append(\"로그인 성공\")if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() GetLoginInfo 메서드는 이벤트 방식으로 동작하는 것도 아니므로 단순히 dynamicCall 메서드를 통해 호출하면 값을 바로 얻을 수 있음. 다만 메서드의 인자가 한 개인데 실제 인자를 넘겨주는 부분에서 다음 코드와 같이 반드시 리스트 형태로 값을 넘겨줘야 함. 1account_num = self.kiwoom.dynamicCall(\"GetLoginInfo(QString)\", [\"ACCNO\"] 함수의 인자로 ACCNO를 넘겨주면 서버는 전체 계좌를 반환해주는데 각 계좌 번호에는 세미콜론이 붙어 있어 계좌 번호를 출력할 때 문자열의 rstrip 메서드를 사용하여 문자열 끝의 세미콜론을 제거. ¶종목 코드 및 한글명 얻어 오기 증권사 API를 사용할 때 종목 코드는 가장 기본이 되는 데이터. 따라서 종목 코드를 API를 통해서 먼저 얻어 와야 각 종목에 대한 반복적인 작업 등을 자동화시킬 수 있음. 종목 코드 목록을 얻어오는 메서드는 GetCodeListByMarket. 종목 코드로부터 한글 종목명을 얻기 위해서는 GetMasterCodeName 사용. 종목 코드 및 종목 한글명 얻어 오기1234567891011121314151617181920212223242526272829303132333435363738import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QAxContainer import *class MyWindow(QMainWindow): def __init__(self): super().__init__() self.kiwoom = QAxWidget(\"KHOPENAPI.KHOpenAPICtrl.1\") self.kiwoom.dynamicCall(\"CommConnect()\") self.setWindowTitle(\"종목 코드\") self.setGeometry(300, 300, 300, 150) btn1 = QPushButton(\"종목코드 얻기\", self) btn1.move(190, 10) btn1.clicked.connect(self.btn1_clicked) self.listWidget = QListWidget(self) self.listWidget.setGeometry(10, 10, 170, 130) def btn1_clicked(self): ret = self.kiwoom.dynamicCall(\"GetCodeListByMarket(QString)\", [\"0\"]) kospi_code_list = ret.split(';') kospi_code_name_list = [] for x in kospi_code_list: name = self.kiwoom.dynamicCall(\"GetMasterCodeName(QString)\", [x]) kospi_code_name_list.append(x + \" : \" + name) self.listWidget.addItems(kospi_code_name_list)if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() sys.exit(app.exec_()) 종목 코드 및 종목 한글명을 출력하기 위해 QListWidget 위젯 사용. GetCodeListByMarket 메서드의 리턴 값은 문자열이고 해당 문자열 내에서 각 종목은 세미콜론으로 구분. 종목 코드를 효과적으로 관리하기 위해 세미콜론을 기준으로 문자열을 분리하여 파이썬 리스트를 생성. 1kospi_code_list = ret.split(';') 한글 종목명 얻기1234kospi_code_name_list = []for x in kospi_code_list: name = self.kiwoom.dynamicCall(\"GetMasterCodeName(QString)\", [x]) kospi_code_name_list.append(x + \" : \" + name) 종목 코드와 종목 한글명이 저장된 파이썬 리스트를 addItems 메서드의 인자로 넘겨주어 파이썬 리스트에 있는 항목들이 QListWidget에 추가되도록 해줌. 1self.listWidget.addItems(kospi_code_name_list)","categories":[{"name":"Auto Trading System","slug":"auto-trading-system","permalink":"https://ultrasound.github.io/categories/auto-trading-system/"}],"tags":[{"name":"kiwoom","slug":"kiwoom","permalink":"https://ultrasound.github.io/tags/kiwoom/"},{"name":"API","slug":"api","permalink":"https://ultrasound.github.io/tags/api/"}]},{"title":"Kiwoom method","slug":"kiwoom-method","date":"2017-11-21T06:30:28.545Z","updated":"2017-11-13T00:43:52.000Z","comments":true,"path":"2017/11/21/kiwoom-method/","link":"","permalink":"https://ultrasound.github.io2017/11/21/kiwoom-method/","excerpt":"","text":"¶CommConnect CommConnect 메서드는 인자를 갖지 않으며 반환 값을 통해 로그인 성공 여부를 확인. 1self.kiwoom.dynamicCall(\"CommConnect()\") ¶CommRqData TR을 서버로 송신 ¶GetConnectState 현재 접속 상태를 반환하는 메서드 메서드의 리턴 값을 확인함으로 서버 접속 상태를 확인 가능. 1234if self.kiwoom.dynamicCall(\"GetConnectState()\") == 0: self.statusBar().showMessage(\"Not connected\")else: self.statusBar().showMessage(\"Connected\") ¶OnEventConnect OnEventConnect 함수의 인자로 nErrCode라는 정숫값이 입력되는데 해당 값이 0이면 로그인 성공, 음수이면 로그인 실패. PyQt에서 OpenAPI+의 이벤트를 처리하려면 이벤트 함수의 원형을 참조해서 해당 이벤트를 처리할 메서드를 구현해야 함. 123def event_connect(self, err_code): if err_code == 0: self.text_edit.append(\"로그인 성공\") ¶OnReceiveTrData 서버와 통신 후 서버로 부터 데이터를 전달받은 시점에 발생. 이벤트는 총 9개의 인자가 전달됨. 12def receive_trdata(self, screen_no, rqname, trcode, recordname, prev_next, data_len, err_code, msg1, msg2): pass ¶OnReceiveRealData 실시간 데이터를 받는 곳으로 주식시장이 열려있는 동안에만 발동 됨. 가격이나 거래량, 호가상태등이 변동 할 때 이벤트가 발생(setrealreg이용) ¶OnReceiveChejanData 체결 데이터를 받은 시점을 알려준다. 1self.OnReceiveChejanData.connect(self._receive_chejan_data) ¶CommGetData 더 이상 지원하지 않을 함수(2017년 11월 25일 현재는 지원) TR 데이터, 실시간 데이터, 체결잔고 데이터 등을 얻어올 수 있음. CommGetData 메서드는 OpenAPI+가 제공하는 메서드이므로 이를 파이썬에서 사용하려면 dynamicCall 메서드를 사용해야 함. 그리고 OpenAPI+에는 수많은 TR이 있으므로 CommGetData의 첫 번째 인자와 세 번째 인자에 TR 명과 Request 명을 입력하여 어떤 TR에 대한 데이터를 얻고자 하는지 알려줘야 함. 1234567def receive_trdata(self, screen_no, rqname, trcode, recordname, prev_next, data_len, err_code, msg1, msg2): if rqname == \"opt10001_req\": name = self.kiwoom.dynamicCall(\"CommGetData(QString, QString, QString, int, QString)\", trcode, \"\", rqname, 0, \"종목명\") volume = self.kiwoom.dynamicCall(\"CommGetData(QString, QString, QString, int, QString)\", trcode, \"\", rqname, 0, \"거래량\") self.text_edit.append(\"종목명: \" + name.strip()) self.text_edit.append(\"거래량: \" + volume.strip()) 위의 코드에서 receive_trdata 메서드는 OnReceiveTrData 이벤트가 발생할 때마다 자동으로 호출. 어떤 TR 요청에 의해 OnReceiveTrData 이벤트가 발생했는지를 확인하기 위해 먼저 사용자 Request 명(rqname)을 확인. 앞서 CommRqData를 통해 서버에 TR을 송신 할 때 Request 명으로 opt10001_req을 설정했으므로 receive_trdata 메서드에서는 rqname 값이 opt10001_req인지 확인. ¶GetCommData ¶GetCommRealData ¶GetLoginInfo 계좌 개수, 계좌 번호, 사용자 ID, 사용자명등의 정보를 얻어올 수 있음. 1account_num = self.kiwoom.dynamicCall(\"GetLoginInfo(QString)\", [\"ACCNO\"]) ¶GetCodeListByMarket 종목 코드 목록을 얻어오는 메서드. 메서드의 인자로 시장 구분 코드를 문자열로 넘겨주면 메서드의 리턴 값으로 해당 시장에 속해 있는 종목들의 종목 코드 목록을 반환. 1ret = self.kiwoom.dynamicCall(\"GetCodeListByMarket(QString)\", [\"0\"]) ¶GetMasterCodeName 종목 코드로부터 한글 종목명을 얻기 위해 사용 1234kospi_code_name_list = []for x in kospi_code_list: name = self.kiwoom.dynamicCall(\"GetMasterCodeName(QString)\", [x]) kospi_code_name_list.append(x + \" : \" + name) ¶GetRepeatCnt 123def _get_repeat_cnt(self, trcode, rqname): ret = self.dynamicCall(\"GetRepeatCnt(QString, QString)\", trcode, rqname) return ret ¶SendOrder 주식 주문에 대한 정보를 서버로 전송. 다만, 증권사 서버에 주문 요청을 했다고 해서 즉시 체결되는 것이 아니므로 이벤트 루프를 사용해 대기하고 있어야 함. 총 9개의 인자를 받음 123def send_order(self, rqname, screen_no, acc_no, order_type, code, quantity, price, hoga, order_no): self.dynamicCall(\"SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)\", [rqname, screen_no, acc_no, order_type, code, quantity, price, hoga, order_no]) ¶GetChejanData 체결잔고 데이터를 반환. 123def get_chejan_data(self, fid): ret = self.dynamicCall(\"GetChejanData(int)\", fid) return ret get_chejan_data 메서드는 함수 인자인 FID 값을 통해 서로 다른 데이터를 얻을 수 있음. 더 자세한 FID 정보는 개발 가이드 8.19절을 참조. FID 설명 9203 주문번호 302 종목명 900 주문수량 901 주문가격 902 미체결수량 904 원주문번호 905 주문구분 908 주문/체결시간 909 체결번호 911 체결량 10 현재가, 체결가, 실시간 종가 ¶SetInputValue 12def set_input_value(self, id, value): self.dynamicCall(\"SetInputValue(QString, QString)\", id, value) ¶Link 파이썬으로 배우는 알고리즘 트레이딩","categories":[{"name":"Auto Trading System","slug":"auto-trading-system","permalink":"https://ultrasound.github.io/categories/auto-trading-system/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ultrasound.github.io/tags/python/"},{"name":"kiwoom","slug":"kiwoom","permalink":"https://ultrasound.github.io/tags/kiwoom/"},{"name":"trading","slug":"trading","permalink":"https://ultrasound.github.io/tags/trading/"}]},{"title":"python trading system","slug":"python-trading-system","date":"2017-11-21T04:55:01.953Z","updated":"2017-11-21T04:57:10.000Z","comments":true,"path":"2017/11/21/python-trading-system/","link":"","permalink":"https://ultrasound.github.io2017/11/21/python-trading-system/","excerpt":"","text":"개발 1일차 개발 2일차 개발 3일차 개발 4일차 ¶요구 사항 Anaconda - Python 3.5 32 bit Pycharm IDE는 항상 관리자 권한으로 실행. 키움증권 계좌 개설 키움증권 OpenAPI+ 신청 OpenAPI+ 모듈 ¶사전 작업 Anaconda 32bit 설치 Python 3.5 사용 환경 만들기 - conda create -n [envname] python=3.5 anaconda 번개 HTS 설치. 키움 Open API+ 설치. ¶개발 1일차 ¶1) 자동 버전처리 스크립트 OpenAPI+를 이용해 개발한 프로그램에서 로그인을 시도할 때 버전 처리가 필요하면 버전 처리 메시지 창이 아래와 같이 나타남. 버전 처리를 가장 쉽게 할 수 있는 방법은 번개 HTS를 사용하는 것. 번개 HTS를 실행하면 자동으로 버전 처리가 완료되기 때문에 OpenAPI+를 사용해 개발한 프로그램을 실행하기 전에 먼저 번개 HTS를 실행하면 버전 처리 문제가 해결됨. 고객 ID와 비밀번호를 입력하는 자동화는 pywinauto 패키지를 이용하면 해결. pywinauto 패키지는 윈도우 대화상자에 자동으로 마우스나 키보드 이벤트를 보낼 수 있음. pip install pywinauto를 입력해 패키지를 설치 pywinquto 패키지를 이용해 코드를 작성하기 위해 PyCharm과 같은 파이썬 IDE를 관리자 권한으로 실행. 아래와 같이 코드를 작성 후 실행하면 키움 번개 로그인 창이 출력 됨. 로그인 창 출력12345678910from pywinauto import applicationfrom pywinauto import timingsimport timeimport osapp = application.Application()app.start(\"C:/Kiwoom/KiwoomFlash3/bin/nkministarter.exe\")title = \"번개3 Login\"dlg = timings.WaitUntilPasses(20, 0.5, lambda: app.window_(title=title)) 마우스와 키보드 입력 자동화 마우스와 키보드 입력 자동화12345678910pass_ctrl = dlg.Edit2pass_ctrl.SetFocus()pass_ctrl.TypeKeys('xxxx') # 로그인 비밀 번호 입력cert_ctrl = dlg.Edit3cert_ctrl.SetFocus()cert_ctrl.TypeKyes('yyyy') # 인증 비밀 번호 입력btn_ctrl = dlg.Button0btn_ctrl.Click() 위의 모든 코드를 실행하면 자동으로 로그인이 이뤄진 후 아래와 같이 키움 번개가 정상적으로 실행되는 것을 확인. 이 과정에서 업데이트가 있는 경우 업데이트 파일을 다운로드하기 때문에 자동으로 버전 처리가 완료 됨. 윈도우에서는 taskkill 명령을 이용해 특정 프로그램을 종료할 수 있음. 파이썬에서 윈도우 명령을 실행하려면 os 모듈의 system 함수를 사용하면 됨. 참고로 로그인 후에 업데이트를 수행하는 과정에 시간이 소용되기 때문에 time.sleep 함수를 호출해 약 50초 정도 대기. 50초 후 키움 종료12time.sleep(50)os.system(\"taskkill /im nkmini.exe\") 전체코드123456789101112131415161718192021222324from pywinauto import applicationfrom pywinauto import timingsimport timeimport osapp = application.Application()app.start(\"C:/Kiwoom/KiwoomFlash2/khministarter.exe\")title = \"번개 Login\"dlg = timings.WaitUntilPasses(20, 0.5, lambda: app.window_(title=title))pass_ctrl = dlg.Edit2pass_ctrl.SetFocus()pass_ctrl.TypeKeys('xxxx')cert_ctrl = dlg.Edit3cert_ctrl.SetFocus()cert_ctrl.TypeKeys('yyyy')btn_ctrl = dlg.Button0btn_ctrl.Click()time.sleep(50)os.system(\"taskkill /im khmini.exe\") 만약 PyCharm을 관리자 권한으로 실행하기 않을 경우 아래와 같은 에러가 발생. 윈도우 대화상자의 이름과 각 컨트롤의 이름을 알아내가 위해 SWAPY 라는 실행 프로그램을 사용. ¶2) 윈도우 작업 스케쥴러 윈도우의 작업 스케쥴러를 이용해 정해진 시간에 파이썬 스크립트 자동 실행. python.exe 대신 pythonw.exe를 선택한 것은 스크립트 실행 시 콘솔 ¶3) PyTrader 구현 Qt Designer를 이용해 메인 윈도우를 만듬. PyQt를 이용한 GUI 프로그래밍 참조. 프로그램에 사용할 무료 아이콘 MyIconFinder 나 Flaticon PyTrader에서 UI는 Qt Designer를 통해 생성한 pytrader.ui 파일을 불러와서 사용. 키움 OpenAPI+와 관련된 코드는 Kiwoom 클래스를 사용. Kiwoom.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import sysfrom PyQt5.QtWidgets import *from PyQt5.QAxContainer import *from PyQt5.QtCore import *import timeimport pandas as pdimport sqlite3TR_REQ_TIME_INTERVAL = 0.2class Kiwoom(QAxWidget): def __init__(self): super().__init__() self._create_kiwoom_instance() self._set_signal_slots() def _create_kiwoom_instance(self): self.setControl(\"KHOPENAPI.KHOpenAPICtrl.1\") def _set_signal_slots(self): self.OnEventConnect.connect(self._event_connect) self.OnReceiveTrData.connect(self._receive_tr_data) def comm_connect(self): self.dynamicCall(\"CommConnect()\") self.login_event_loop = QEventLoop() self.login_event_loop.exec_() def _event_connect(self, err_code): if err_code == 0: print(\"connected\") else: print(\"disconnected\") self.login_event_loop.exit() def get_code_list_by_market(self, market): code_list = self.dynamicCall(\"GetCodeListByMarket(QString)\", market) code_list = code_list.split(';') return code_list[:-1] def get_master_code_name(self, code): code_name = self.dynamicCall(\"GetMasterCodeName(QString)\", code) return code_name def get_connect_state(self): ret = self.dynamicCall(\"GetConnectState()\") return ret def set_input_value(self, id, value): self.dynamicCall(\"SetInputValue(QString, QString)\", id, value) def comm_rq_data(self, rqname, trcode, next, screen_no): self.dynamicCall(\"CommRqData(QString, QString, int, QString)\", rqname, trcode, next, screen_no) self.tr_event_loop = QEventLoop() self.tr_event_loop.exec_() def _comm_get_data(self, code, real_type, field_name, index, item_name): ret = self.dynamicCall(\"CommGetData(QString, QString, QString, int, QString)\", code, real_type, field_name, index, item_name) return ret.strip() def _get_repeat_cnt(self, trcode, rqname): ret = self.dynamicCall(\"GetRepeatCnt(QString, QString)\", trcode, rqname) return ret def _receive_tr_data(self, screen_no, rqname, trcode, record_name, next, unused1, unused2, unused3, unused4): if next == '2': self.remained_data = True else: self.remained_data = False if rqname == \"opt10081_req\": self._opt10081(rqname, trcode) try: self.tr_event_loop.exit() except AttributeError: pass def _opt10081(self, rqname, trcode): data_cnt = self._get_repeat_cnt(trcode, rqname) for i in range(data_cnt): date = self._comm_get_data(trcode, \"\", rqname, i, \"일자\") open = self._comm_get_data(trcode, \"\", rqname, i, \"시가\") high = self._comm_get_data(trcode, \"\", rqname, i, \"고가\") low = self._comm_get_data(trcode, \"\", rqname, i, \"저가\") close = self._comm_get_data(trcode, \"\", rqname, i, \"현재가\") volume = self._comm_get_data(trcode, \"\", rqname, i, \"거래량\") self.ohlcv['date'].append(date) self.ohlcv['open'].append(int(open)) self.ohlcv['high'].append(int(high)) self.ohlcv['low'].append(int(low)) self.ohlcv['close'].append(int(close)) self.ohlcv['volume'].append(int(volume)) pytrader.py 파일에 모듈을 임포트하고 ui 파일을 불러오는 코드를 구현. pytrader.py123456789101112131415161718import sysfrom PyQt5.QtWidgets import *from PyQt5.QtCore import *from PyQt5 import uicfrom Kiwoom import *form_class = uic.loadUiType(\"pytrader.ui\")[0]class MyWindow(QMainWindow, form_class): def __init__(self): super().__init__() self.setupUi(self)if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() PyTrader 프로그램이 실행될 때 키움 로그인이 진행되도록 해주기 위해 생성자에서 키움 객체를 생성한 후 Comm_Connect 메서드를 호출. call comm_connect pytrader.py1234567class MyWindow(QMainWindow, form_class): def __init__(self): super().__init__() self.setupUi(self) self.kiwoom = Kiwoom() self.kiwoom.comm_connect() StatusBar 위젯에 서버 연결 상태 및 현재 시간을 출력하는 기능 구현. 서버 연결 상태는 Kiwoom class에 추가한 get_connect_state 메서드를 사용. 현재 시간을 출력하는 기능은 일정한 단위로 현재 시간을 얻어온 후 이를 StatusBar에 출력. 이를 위해서는 주기적으로 이벤트를 발생시키는 Timer가 필요. 예를 들어, Timer가 1초에 한 번 이벤트(시그널)를 발생시키면 이 이벤트를 처리하는 메서드(슬롯)에서 현재 시간을 얻어온 후 이를 StatusBar에 출력 Qt의 QTimer 클래스를 사용하면 정해진 시간마다 이벤트를 발생시킬 수 있음. 123self.timer = QTimer(self)self.timer.start(1000)self.timer.timeout.connect(self.timout) QTimer 클래스는 start 메서드를 제공, 이 메서드에 인자로 1000을 지정하면 1초에 한 번씩 주기적으로 timeout 시그널이 발생. 따라서 timeout 시그널이 발생할 때 이를 처리할 슬롯으로 self.timeout을 설정하면 됨. timout class pytrader.py123456789101112def timeout(self): current_time = QTime.currentTime() text_time = current_time.toString(\"hh:mm:ss\") time_msg = \"현재시간: \" + text_time state = self.kiwoom.GetConnectState() if state == 1: state_msg = \"서버 연결 중\" else: state_msg = \"서버 미 연결 중\" self.statusbar.showMessage(state_msg + \" | \" + time_msg) 전체 pytrader.py 코드1234567891011121314151617181920212223242526272829303132333435363738import sysfrom PyQt5.QtWidgets import *from PyQt5.QtCore import *from PyQt5 import uicfrom Kiwoom import *form_class = uic.loadUiType(\"pytrader.ui\")[0]class MyWindow(QMainWindow, form_class): def __init__(self): super().__init__() self.setupUi(self) self.kiwoom = Kiwoom() self.kiwoom.comm_connect() self.timer = QTimer(self) self.timer.start(1000) self.timer.timeout.connect(self.timeout) def timeout(self): current_time = QTime.currentTime() text_time = current_time.toString(\"hh:mm:ss\") time_msg = \"현재시간: \" + text_time state = self.kiwoom.get_connect_state() if state == 1: state_msg = \"서버 연결 중\" else: state_msg = \"서버 미 연결 중\" self.statusbar.showMessage(state_msg + \" | \" + time_msg)if __name__ == \"__main__\": app = QApplication(sys.argv) myWindow = MyWindow() myWindow.show() app.exec_() ¶4) 키움 OpenAPI+ 자동 로그인 자동화를 위해 사용자 계정 컨트롤 기능 비활성화 키움 증권 로그인 과정 자동화. 키움증권은 사용자의 편의를 위해 자동 로그인 기능을 지원. 자동 로그인 설정을 위해 pytrader.py 파일을 실행시켜 로그인을 진행. 정상적으로 로그인되면 아래와 같이 윈도우 오른쪽 아래의 아이콘 중 키움증권 아이콘에서 마우스 오른쪽 버튼을 클릭한 후 계좌비밀번호 저장을 선택. 자동 로그인 설정은 계좌 단위로 가능한데, 계좌를 선택한 후 등록 부분에 계좌 비밀번호를 입력하고 등록 버튼을 눌러 등록. 비밀번호가 잘 등록되면 AUTO라는 체크박스를 체크. 설정을 모두 완료했다면 실행시킨 PyTrader 프로그램을 종료. 그리고 다시 pytrader.py 파일을 실행해 보면 로그인 창이 화면에 나타나지 않고 바로 로그인이 수행된 후 PyTrader 프로그램이 실행 됨. ¶정리 윈도우 작업 스케쥴러를 이용해 매일 08:00에 키움 번개 자동 로그인 스크립트(login.py)를 실행. 해당 스크립트가 실행되면 키움 번개에 로그인되면 버전 처리 완료. 키움 번개 HTS 자동 종료. 08:15 윈도우 작업 스케쥴러를 이용해 pytrader.py 파일을 실행. 이때 위 그림 같이 자동 로그인 설정해 둠. 아래 그림과 같은 순서로 프로그램이 실행되게 해두면 버전 처리 및 로그인 자동화. PyTrader 개발과 관련해서 키움 OpenAPI+ 관련 코드는 모두 Kiwoom.py에 구현. UI는 Qt Designer를 사용해 pytrader.ui 파일에 구현. pytrader.py에는 이벤트 처리하는 코드만 구현. ¶에러사항 KOA Studio에서 모의투자 체크 박스가 정상적으로 안되는 경우 발생. 일단 모의 투자로 접속하고 계좌비밀번호 저장에서 AUTO 체크박스 해제로 일반 투자로 접속 가능. 모의투자는 최대 3개월만 사용가능하여 기간 종료 시에는 모의 투자로 접속이 안되어 다시 모의 투자 가입하여야 함. ¶개발 2일차 주문 기능 추가. ¶1) UI 구성 QGroupBox 위젯을 MainWindow 안으로 배치. Label을 선택. Label은 PyQt의QLabel` 클래스에 해당. Combo Box를 선택. Combo Box는 QComboBox 클래스를 의미 세 개의 Combo Box를 Main Window에 배치. Combo Box 위젯을 더블클릭하면 아래와 같이 세부 항목을 추가 할 수 있는 창이 나타남. Line Edit를 선택한 후 배치. Line Edit는 QLineEdit 클래스에 해당. Spin Box를 선택한 후 수량과 가격 옆으로 배치. Push Button을 선택한 후 맨 아래쪽에 배치. ¶2) Kiwoom.py 파일 업데이트 주문과 관련된 API를 처리하는 메서드를 구현. SendOrder 메서드를 사용하면 주식 주문에 대한 정보를 서버로 전송. 주문이 체결되면 증권사 서버는 아래와 같이 OnReceiveChejanData라는 이벤트를 발생. 앞서 OnReceiveTrData 메서드 내에서 CommGetData 메서드를 호출해 데이터를 얻어왔던 것과 동일하게 체결과 관련해서는 OnReceiveChejanData라는 메서드 내에서 GetChejanData라는 메서드를 호출해서 체결잔고 데이터를 얻어 옴. Kiwoom 클래스에 send_order 메서드를 추가 123def send_order(self, rqname, screen_no, acc_no, order_type, code, quantity, price, hoga, order_no): self.dynamicCall(\"SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)\", [rqname, screen_no, acc_no, order_type, code, quantity, price, hoga, order_no]) 체결잔고 데이터를 가져오는 메서드인 GetChejanData를 사용하는 get_chejan_data 메서드를 Kiwoom 클래스에 추가. 123def get_chejan_data(self, fid): ret = self.dynamicCall(\"GetChejanData(int)\", fid) return ret 주문체결 시점에서 키움증권 서버가 발생시키는 OnReceiveChejanData 이벤트를 처리하는 메서드를 구현. 먼저 _set_signal_slots 메서드에 시그널과 슬롯을 연결하는 코드 추가. 1self.OnReceiveChejanData.connect(self._receive_chejan_data) OnReceiveChejanData 이벤트가 발생할 때 호출되는 _receive_chejan_data는 다음과 같이 구현. 123456def _receive_chejan_data(self, gubun, item_cnt, fid_list): print(gubun) print(self.get_chejan_data(9203)) print(self.get_chejan_data(302)) print(self.get_chejan_data(900)) print(self.get_chejan_data(901)) get_chejan_data 메서드는 함수 인자인 FID 값을 통해 서로 다른 데이터를 얻을 수 있음. 더 자세한 FID 정보는 개발 가이드 8.19절을 참조. FID 설명 9203 주문번호 302 종목명 900 주문수량 901 주문가격 902 미체결수량 904 원주문번호 905 주문구분 908 주문/체결시간 909 체결번호 911 체결량 10 현재가, 체결가, 실시간 종가 OpenAPI+에서 계좌 정보 및 로그인 사용자 정보를 얻어오는 메서드는 GetLoginInfo. 다음과 같이 dynamicCall 메서드로 GetLoginInfo 메서드를 호출하는 get_login_info 메서드를 Kiwoom 클래스에 추가. 123def get_login_info(self, tag): ret = self.dynamicCall(\"GetLoginInfo(QString)\", tag) return ret ¶3) pytrader.py 파일 업데이트 가장 먼저 추가할 기능은 QLinkEdit 위젯에 사용자가 코드명을 입력하면 해당 코드에 대한 종목명을 출력하는 기능. pytrader.py 파일에 위젯에 대한 코드를 구현할 때 가장 먼저 할 일은 위젯의 이름을 파악하는 것. 사용자가 lineEdit 객체에 종목 코드를 입력하면 PyTrader는 사용자가 입력한 종목 코드를 읽은 후 키움증권의 OpenAPI+를 사용하여 종목명을 알아내야 함. 이를 위해 먼저 lineEdit 객체가 변경될 때 호출되는 슬롯을 지정. 1self.lineEdit.textChanged.connect(self.code_changed) 위에서 시그널 슬롯을 설정했기 때문에 lineEdit 객체로부터 textChanged라는 이벤트가 발생하면 MyWindow 클래스의 code_changed 메서드가 호출될 것임. MyWindow 클래스에 code_changed 메서드를 다음과 같이 구현. 먼저 사용자가 입력한 종목 코드를 얻어 옴. 종목 코드에 대한 종목명은 Kiwoom 클래스에 구현된 get_master_code_name 메서드를 호출하여 알아냄. 1234def coe_changed(self): code = self.lineEdit.text() name = self.kiwoom.get_master_code_name(code) self.lineEdit_2.ssetText(name) 계좌 정보를 QComboBox 위젯에 출력하는 코드 구현. 이를 위해 먼저 전체 계좌 개수와 계좌 번호를 키움증권으로부터 얻어 옴. Kiwoom 클래스의 get_login_info 메서드를 사용하여 다음과 같이 필요한 데이터를 얻어 옴. 12accouns_num = int(self.kiwoom.get_login_info(\"ACCOUNT_CNT\"))accounts = self.kiwoom.get_login_info(\"ACCNO\") 계좌 번호를 QComboBox 위젯에 출력하려면 아래와 같이 먼저 objectName을 확인. 계좌가 여러 개인 경우 각 계좌는 ;를 통해 구분됨. 따라서 먼저 얻어온 전체 계좌에 대해 split 메서드를 호출하여 리스트로 분리한 후 슬라이시을 통해 출력할 계좌번호를 선택. 계좌를 QComboBox에 출력하기 위해 addItems 메서드를 호출. 12accounts_list = accounts.split(';')[0:accouns_num]self.comboBox.addItems(accounts_list) 마지막으로 현금주문에 대한 코드를 구현. 현금주문은 UI 창에서 현금주문 버튼을 클릭할 때 수행됨. 따라서 먼저 버튼의 이름을 확인한 후 해당 버튼에 대한 시그널과 슬롯을 연결. 1self.pushButton.clicked.connect(self.send_order) send_order 메서드를 구현 주의할 점은 사용자는 QComboBox를 통해 ‘신규매수’, ‘신규매도’, ‘매수취소’, '매도취소’와 같은 세부 항목을 선택하지만 실제 키움증권의 API에는 세부 항목에 대응되는 정숫값이 전달돼야 함. 마찬가지로 호가에서도 지정가일 때는 00이라는 문자열을 전달해야 하고, 시장가일 때는 03이라는 문자열을 전달해야 함. 123456789101112def send_order(self): order_type_lookup = &#123;'신규매수': 1, '신규매도': 2, '매수취소': 3, '매도취소': 4&#125; hoga_lookup = &#123;'지정가': \"00\", '시장가': \"03\"&#125; account = self.comboBox.currentText() order_type = self.comboBox_2.currentText() code = self.lineEdit.text() hoga = self.comboBox_3.currentText() num = self.spinBox.value() price = self.spinBox_2.value() self.kiwoom.send_order(\"send_order_req\", \"0101\", account, order_type_lookup[order_type], code, num, price, hoga_lookup[hoga], \"\") ¶4) 매수 테스트 pytrader.py 파일을 관리자 권한으로 실행. 거래할 계좌 번호를 선택한 후 주문을 신규매수로 선택. 매수하고자 하는 종목코드를 입력 종류에 시장가를 선택하고 적당한 수량을 입력한 후 현금주문 버튼을 클릭 매수 API가 정상적으로 동작했는지를 확인하는 쉬운 방법은 HTS를 사용하는 것 다른 방법은 KOA Studio를 사용하는 것. 아래 그림처럼 TR 목록에서 opt10085를 선택한 후 오른쪽 계좌번오에 계좌번호를 입력한 후 조회 버튼을 클릭하면 화면 하단 출력부에 데이터가 출력. ¶개발 3일차 보유 주식 현황 출력과 잔고확인 기능 구현. ¶1) UI 구성 Table Widget을 선택한 후 아래와 같이 Property Editor에서 QTableWidget 항목에서 rowCount 값을 1로 변경. QTableWidget 객체는 rowCount 값을 제대로 설정하지 않으면 아이템을 추가할 수 없으므로 반드시 값을 설정. Check Box의 경우 Property Editor에서 text 항목을 실시간 조회로 변경하고 버튼의 text 항목을 조회로 변경. ¶2) Kiwoom.py 파일 업데이트 KOA Studio를 참고하면 잔고 및 보유종목 현황 출력 기능에 필요한 대부분의 데이터는 opw00018이라는 TR를 통해 얻을 수 있음. 예수금 정보는 opw00001 TR을 사용. 먼저 OnReceiveTrData 이벤트가 발생할 때 수신 데이터를 가져오는 함수인 _opw0001를 Kiwoom 클래스에 추가. 12def _opw00001(self, rqname, trcode): self.d2_deposit = self._comm_get_data(trcode, \"\", rqname, 0, \"d+2추정예수금\") _receive_tr_data 메서드를 구현할 때 다음 세가지 고려 사항 여러 종류의 TR을 요청해도 모두 _receive_tr_data 메서드 내에서 처리해야 함. 따라서 rqname이라는 인자를 통해서 요청한 TR을 구분한 후 TR에 따라서 적당한 데이터를 가져오도록 코딩. 연속조회에 대한 처리. 이벤트 루프에 대한 처리. _receive_tr_data 메서드에서 _opw00001 메서드를 호출하도록 코드 수정. 12345if rqname == \"opt10081_req\": self._opt10081(rqname, trcode)elif rqname == \"opw00001_req\": self._opw00001(rqname, trcode) d+2 추정예수금을 잘 얻어오는지 확인하기 위해 Kiwoom.py 파을이 main 코드 부분을 아래와 같이 수정. Kiwoom.py12345678910if __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) kiwoom = Kiwoom() kiwoom.comm_connect() kiwoom.set_input_value(&quot;계좌번호&quot;, &quot;8087711111&quot;) kiwoom.set_input_value(&quot;비밀번호&quot;, &quot;0000&quot;) kiwoom.comm_rq_data(&quot;opw00001_req&quot;, &quot;opw00001&quot;, 0, &quot;2000&quot;) print(kiwoom.de_deposit) 얻어온 d+2추정예수금을 확인하면 000000499225300와 같이 문자열의 앞쪽에 0이 존재하는 것을 확인. 보통 금액은 천의 자리마다 콤마를 사용하여 표시. 이를 위해 Kiwoom 클래스에 change_format이라는 static method를 추가. change_format 메서드는 입력된 문자열에 대해 lstrip 메서드를 통해 문자열 왼쪽에 존재하는 - 또는 0을 제거. 그리고 format 함수를 통해 천의 자리마다 콤마를 추가한 문자열로 변경. staticmethod1234567891011@staticmethoddef change_format(data): strip_data = data.lstrip('-0') if strip_data == '': strip_data = '0' format_data = format(int(strip_data), ',d') if data.startswith('-'): format_data = '-' + format_data return format_data 정적 메서드를 호출하려면 정적 메서드 이름 앞에 클래스 이름을 붙여줌. 123def _opw00001(self, rqname, trcode): d2_deposit = self._comm_get_data(trcode, \"\", rqnam, 0, \"d+2추정예수금\") self.d2_deposit = Kiwoom.change_format(d2_deposit) 총매입금액, 총평가금액, 총평가손익금액, 총수익률, 추정예탁자산을 _comm_get_data 메서드를 통해 얻어 옴. 얻어온 데이터는 change_format 메서드를 통해 포맷을 문자열로 변경 123456789101112def _opw00018(self, rqname, trcode): total_purchase_price = self._comm_get_data(trcode, \"\", rqname, 0, \"총매입금액\") total_eval_price = self._comm_get_data(trcode, \"\", rqname, 0, \"총평가금액\") total_eval_profit_loss_price = self._comm_get_data(trcode, \"\", rqname, 0, \"총평가손익금액\") total_earning_rate = self._comm_get_data(trcode, '', rqname, 0, \"총수익률(%)\") estimated_deposit = self._comm_get_data(trcode, '', rqname, 0, \"추정예탁자산\") print(Kiwoom.change_format(total_purchase_price)) print(Kiwoom.change_format(total_eval_price)) print(Kiwoom.change_format(total_eval_profit_loss_price)) print(Kiwoom.change_format(total_earning_rate)) print(Kiwoom.change_format(estimated_deposit)) _receive_tr_data 메서드에서 _opw00018 메서드를 호출하도록 코드 수정. 123456if rqname == \"opt10081_req\": self._opt10081(rqname, trcode)elif rqname == \"opw00001_req\": self._opw00001(rqname, trcode)elif rqname == \"opw0001_req\": self._opw00018(rqname, trcode) opw00018 TR을 통해 싱글 데이터를 잘 얻어오는지 테스트하기 위해 Kiwoom.py 파일의 __main__ 코드 부분을 수정. 12345678910if __name__ == \"__main__\": app = QApplication(sys.argv) kiwoom = Kiwoom() kiwoom.comm_connect() account_number = kiwoom.get_login_info(\"ACCNO\") account_number = account_number.split(';')[0] kiwoom.set_input_value(\"계좌번호\", account_number) kiwoom.comm_rq_data(\"opw00018_req\", \"opw00018\", 0, \"2000\") 만약 Kiwoom.py 파일을 실행했을 때 아래와 같은 에러가 발생한다면 계좌 비밀번호 등록한 후 자동 로그인 설정 해줌. 멀티 데이터를 통해 보유 종목별 평가 잔고 데이터를 가져오기. 다음 코드를 _opw00018에 추가. 멀티 데이터는 _get_repeat_cnt 메서드를 호출하여 보유 종목의 개수를 얻어 옴. 그런 다음 해당 개수마큼 반복하면서 각 보유 종목에 대한 상세 데이터를 _comm_get_data를 통해 얻어 옴. 참고로 opw00018 TR을 사용하는 경우 한 번의 TR 요청으로 최대 20개의 보유 종목에 대한 데이터를 얻을 수 있음. 1234567891011121314151617# multi datarows = self._get_repeat_cnt(trcode, rqname)for i in range(rows): name = self._comm_get_data(trcode, \"\", rqname, i, \"종목명\") quantity = self._comm_get_data(trcode, \"\", rqname, i, \"보유수량\") purchase_price = self._comm_get_data(trcode, \"\", rqname, i, \"매입가\") current_price = self._comm_get_data(trcode, \"\", rqname, i, \"현재가\") eval_profit_loss_price = self._comm_get_data(trcode, \"\", rqname, i, \"평가손익\") earning_rate = self._comm_get_data(trcode, \"\", rqname, i, \"수익률(%)\") quantity = Kiwoom.change_format(quantity) purchase_price = Kiwoom.change_format(purchase_price) current_price = Kiwoom.change_format(current_price) eval_profit_loss_price = Kiwoom.change_format(eval_profit_loss_price) earning_rate = Kiwoom.change_format2(earning_rate) print(name, quantity, purchase_price, current_price, eval_profit_loss_price, earning_rate) 수익률에 대한 포맷 변경은 change_format2라는 정적 메서드를 사용. 1234567891011121314@staticmethoddef change_format2(data): strip_data = data.lstrip('-0') if strip_data == '': strip_data = '0' if strip_data.startswith('.'): strip_data = '0' + strip_data if data.startswith('-'): strip_data = '-' + strip_data return strip_data opw00018 TR을 통해 얻어온 데이터를 인스턴스 변수에 저장 Kiwoom 클래스에 다음 메서드 추가 12def reset_opw00018_output(self): self.opw00018_output = &#123;'single': [], 'multi': []&#125; _opw00018 메서드는 아래와 같이 수정. 싱글 데이터는 1차원 리스트로 데이터를 저장, 멀티 데이터는 2차원 리스트로 데이터를 저장. 12345678910111213141516171819202122232425262728293031def _opw00018(self, rqname, trcode): # single data total_purchase_price = self._comm_get_data(trcode, \"\", rqname, 0, \"총매입금액\") total_eval_price = self._comm_get_data(trcode, \"\", rqname, 0, \"총평가금액\") total_eval_profit_loss_price = self._comm_get_data(trcode, \"\", rqname, 0, \"총평가손익금액\") total_earning_rate = self._comm_get_data(trcode, \"\", rqname, 0, \"총수익률(%)\") estimated_deposit = self._comm_get_data(trcode, \"\", rqname, 0, \"추정예탁자산\") self.opw00018_output['single'].append(Kiwoom.change_format(total_purchase_price)) self.opw00018_output['single'].append(Kiwoom.change_format(total_eval_price)) self.opw00018_output['single'].append(Kiwoom.change_format(total_eval_profit_loss_price)) self.opw00018_output['single'].append(Kiwoom.change_format(total_earning_rate)) self.opw00018_output['single'].append(Kiwoom.change_format(estimated_deposit)) # multi data rows = self._get_repeat_cnt(trcode, rqname) for i in range(rows): name = self._comm_get_data(trcode, \"\", rqname, i, \"종목명\") quantity = self._comm_get_data(trcode, \"\", rqname, i, \"보유수량\") purchase_price = self._comm_get_data(trcode, \"\", rqname, i, \"매입가\") current_price = self._comm_get_data(trcode, \"\", rqname, i, \"현재가\") eval_profit_loss_price = self._comm_get_data(trcode, \"\", rqname, i, \"평가손익\") earning_rate = self._comm_get_data(trcode, \"\", rqname, i, \"수익률(%)\") quantity = Kiwoom.change_format(quantity) purchase_price = Kiwoom.change_format(purchase_price) current_price = Kiwoom.change_format(current_price) eval_profit_loss_price = Kiwoom.change_format(eval_profit_loss_price) earning_rate = Kiwoom.change_format2(earning_rate) self.opw00018_output['multi'].append([name, quantity, purchase_price, current_price, eval_profit_loss_price, earning_rate]) opw00018 TR을 사용할 때 한가지 주의 사항은 실 서버로 접속할 때와 모의투자 서버로 접속할 때에 제공되는 데이터 형식이 다름. 예를 들어 실 서버에서 수익률은 소수점 표시 없이 전달되지만, 모의투자에선 소수점을 포함해서 데이터가 전달됨. 따라서 접속 서버를 구분하여 데이터를 다르게 처리해야 할 필요가 있음. Kiwoom 클래스에 다음 메서드를 추가 123def get_server_gubun(self): ret = self.dynamicCall(\"KOA_Functions(QString, QString)\", \"GetServerGubun\", \"\") return ret _opw00018 메서드에서 모의투자일 때는 총수익률(%)의 값을 100으로 나눈 후 출력 되도록 다음과 같이 코드 수정. 1234567total_earning_rate = Kiwoom.change_format(total_earning_rate)if self.get_server_gubun(): total_earning_rate = float(total_earning_rate) / 100 total_earning_rate = str(total_earning_rate)self.opw00018_output['single'].append(total_earning_rate) ¶3) pytrader.py 파일 업데이트 Kiwoom 클래스를 사용해 잔고 및 보유종목 현황 데이터를 요청하고 데이터를 UI에 출력하는 코드 작성. call check_balance12# pushButton_2 라는 객체가 클릭될 때 check_balance라는 메서드가 호출self.pushButton_2.clicked.connect(self.check_balance) check_balance 메서드 구현. check_balance method123456789101112def check_balance(self): self.kiwoom.reset_opw00018_output() account_number = self.kiwoom.get_login_info(&quot;ACCNO&quot;) account_number = account_number.split(&apos;;&apos;)[0] self.kiwoom.set_input_value(&quot;계좌번호&quot;, account_number) self.kiwoom.comm_rq_data(&quot;opw00018_req&quot;, &quot;opw00018&quot;, 0, &quot;2000&quot;) while self.kiwoom.remained_data: time.sleep(0.2) self.kiwoom.set_input_value(&quot;계좌번호&quot;, account_number) self.kiwoom.comm_rq_data(&quot;opw00018_req&quot;, &quot;opw00018&quot;, 2, &quot;2000&quot;) 예수금 데이터를 얻기 위해 opw00001 TR을 요청하는 코드 opw00001 TR을 요청하는 코드123# opw00001self.kiwoom.set_input_value(&quot;계좌번호&quot;, account_number)self.kiwoom.comm_rq_data(&quot;opw00001_req&quot;, &quot;opw00001&quot;, 0, &quot;2000&quot;) 데이터가 준비됐다면 데이터를 QTableWidget 객체에 출력하면 됨. self.tableWidget을 통해 해당 객체에 접근 가능. 예수금 데이터를 QTableWidget에 출력하기 위해 먼저 self.kiwoom.d2_deposit에 저장된 예수금 데이터를 QTableWidgetItem 객체로 만들어 줌. setItem 메서드를 호출해 QTableWidget 객체에 넣으면 됨. 1234# balanceitem = QTableWidgetItem(self.kiwoom.d2_deposit)item.setTextAlignment(Qt.AlignVCenter | Qt.AlignRight)self.tableWidget.setItem(0, 0, item) 총매입, 총평가, 총손익, 총수익률(%), 추정자산을 QTableWidget의 칼럼에 추가하는 코드. 데이터는 self.kiwoom.opw00018_output['single']을 통해 얻어올 수 있음. 1234for i in range(1, 6): item = QTableWidgetItem(self.kiwoom.opw00018_output['single'][i - 1]) item.setTextAlignment(QT.AlignVCenter | Qt.AlignRight) self.tableWidget.setItem(0, i, item) resizeRowsToContents 메서드를 호출해서 아이템의 크기에 맞춰 행의 높이를 조절 1self.tableWidget.resizeRowsToContents() 보유 종목별 평가 잔고 데이터를 추가. 먼저 보유종목의 개수를 확인한 후 행의 개수를 설정 123# Item listitem_count = len(self.kiwoom.opw00018_output['multi])self.tableWidget_2.setRowCount(item_count) 한 종목에 대한 종목명, 보유량, 매입가, 현재가, 평가손익, 수익률(%)은 출력 123456for j in range(item_count): row = self.kiwoom.opw00018_output['multi'][j] for i in range(len(row)): item = QTableWidgetItem(row[i]) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignRight) self.tableWidget_2.setItem(j, i, item) check_balance method 전체코드1234567891011121314151617181920212223242526272829303132333435363738394041def check_balance(self): self.kiwoom.reset_opw00018_output() account_number = self.kiwoom.get_login_info(\"ACCNO\") account_number = account_number.split(';')[0] self.kiwoom.set_input_value(\"계좌번호\", account_number) self.kiwoom.comm_rq_data(\"opw00018_req\", \"opw00018\", 0, \"2000\") while self.kiwoom.remained_data: time.sleep(0.2) self.kiwoom.set_input_value(\"계좌번호\", account_number) self.kiwoom.comm_rq_data(\"opw00018_req\", \"opw00018\", 2, \"2000\") # opw00001 self.kiwoom.set_input_value(\"계좌번호\", account_number) self.kiwoom.comm_rq_data(\"opw00001_req\", \"opw00001\", 0, \"2000\") # balance item = QTableWidgetItem(self.kiwoom.d2_deposit) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignRight) self.tableWidget.setItem(0, 0, item) for i in range(1, 6): item = QTableWidgetItem(self.kiwoom.opw00018_output['single'][i - 1]) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignRight) self.tableWidget.setItem(0, i, item) self.tableWidget.resizeRowsToContents() # Item list item_count = len(self.kiwoom.opw00018_output['multi']) self.tableWidget_2.setRowCount(item_count) for j in range(item_count): row = self.kiwoom.opw00018_output['multi'][j] for i in range(len(row)): item = QTableWidgetItem(row[i]) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignRight) self.tableWidget_2.setItem(j, i, item) self.tableWidget_2.resizeRowsToContents() 실시간 조회 체크 박스 구현. 새로운 타이머 객체를 생성 1234# Timer2self.timer2 = QTimer(self)self.timer2.start(1000*10)self.timer2.timeout.connect(self.timeout2) timeout2 메서드 구현. 위의 메서드는 QCheckBox가 체크 됐는지 확인한 후 데이터 갱신. 데이터 갱신 처리는 check_balance 메서드가 담당하고 있으므로 다음과 같이 구현 123def timeout2(self): if self.checkBox.isChecked(): self.check_balance() ¶개발 4일차 선정된 매수/매도 종목을 자동으로 매매하고 해당 종목에 대한 정보를 출력하는 기능 구현. ¶1) UI 구성 및 매수/매도 목록 파일 생성 선정된 매수/매도 종목에 대한 정보가 이미 buy_list.txt라는 파일과 sell_list.txt라는 파일로 저장돼 있다고 가정하고 프로그램을 구현. ¶2) 선정 종목 정보 출력하기 위에서 생성했던 buy_list.txt와 sell_list.txt 파일을 읽어서 이름 QTableWidget 객체로 출력하는 기능을 구현. 출력하는 기능은 load_buy_sell_list라는 이름의 메서드로 구현할 것임. 프로그램 시작되자마자 출력돼야 하므로 MyWindow 클래스의 생성자에서 load_buy_sell_list를 호출. 1234567class MyWindow(QMainWindow, form_class): sef __init__(self): super().__init__() self.setupUi(self) # 중간 코드 생략 self.load_buy_sell_list() load_buy_sell_list method12345678def load_buy_sell_list(self): f = open(\"buy_list.txt\", 'rt') buy_list = f.readlines() f.close() f = open(\"sell_list.txt\", 'rt') sell_list = f.readlines() f.close() 파일로부터 매수/매도 리스트를 읽었다면 데이터의 총 개수를 확인하여 종목 각각에 대한 데이터 개수를 확인한 후 이 두 값을 더한 값을 QTableWidget 객체의 setRowCount 메서드로 설정. 12row_count = len(buy_list) + len(sell_list)self.tablewidget_4.setRowCount(row_count) 12345678910# buy listfor j in range(len(buy_list)): row_data = buy_list[j] split_row_data = row_data.split(';') split_row_data[1] = self.kiwoom.get_master_code_name(split_row_data[1].rsplit()) for i in range(len(split_row_data)): item = QTableWidgetItem(split_row_data[i].rstrip()) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignCenter) self.tableWidget_4.setItem(j, i, item) 12345678910# sell listfor j in range(len(sell_list)): row_data = sell_list[j] split_row_data = row_data.split(';') split_row_data[1] = self.kiwoom.get_master_code_name(split_row_data[1].rstrip()) for i in range(len(split_row_data)): item = QTableWidgetItem(split_row_data[i].rstrip()) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignCenter) self.tableWidget_4.setItem(len(buy_list) + j, i, item) load_buy_sell_list method 전체코드1234567891011121314151617181920212223242526272829303132333435def load_buy_sell_list(self): f = open(&quot;buy_list.txt&quot;, &apos;rt&apos;) buy_list = f.readlines() f.close() f = open(&quot;sell_list.txt&quot;, &apos;rt&apos;) sell_list = f.readlines() f.close() row_count = len(buy_list) + len(sell_list) self.tableWidget_4.setRowCount(row_count) # buy list for j in range(len(buy_list)): row_data = buy_list[j] split_row_data = row_data.split(&apos;;&apos;) split_row_data[1] = self.kiwoom.get_master_code_name(split_row_data[1].rsplit()) for i in range(len(split_row_data)): item = QTableWidgetItem(split_row_data[i].rstrip()) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignCenter) self.tableWidget_4.setItem(j, i, item) # sell list for j in range(len(sell_list)): row_data = sell_list[j] split_row_data = row_data.split(&apos;;&apos;) split_row_data[1] = self.kiwoom.get_master_code_name(split_row_data[1].rstrip()) for i in range(len(split_row_data)): item = QTableWidgetItem(split_row_data[i].rstrip()) item.setTextAlignment(Qt.AlignVCenter | Qt.AlignCenter) self.tableWidget_4.setItem(len(buy_list) + j, i, item) self.tableWidget_4.resizeRowsToContents() ¶3) 자동 주문 구현하기 각 거래일의 장 시작에 맞춰 정해진 주문 방식에 따라 주문을 수행하는 간단한 방식을 사용. 자동 주문하는 기능은 MyWindow 클래스의 trade_stocks 메서드에 구현. 12345678910def trade_stocks(self): hoga_lookup = &#123;'지정가': \"00\", '시장가': \"03\"&#125; f = open(\"buy_list.txt\", 'rt') buy_list = f.readlines() f.close() f = oepn(\"sell_list.txt\", 'rt') sell_list = f.readlines() f.close() 주문할 때 필요한 계좌 정보를 QComboBox 위젯으로부터 얻어 옴. 1account = self.comboBox.currentText() buy_list로 부터 데이터를 하나씩 얻어온 후 문자열을 분리해서 주문에 필요한 정보(거래구분, 종목코드, 수량, 가격)를 준비. 읽어 온 데이터의 주문 수행 여부가 '매수전’인 경우에만 해당 주문 데이터를 토대로 send_order 메서드를 통해 매수 주문을 수행. 12345678910# buy listfor row_data in buy_list: split_row_data = row_data.split(';') hoga = split_row_data[2] code = split_row_data[1] num = split_row_data[3] price = split_row_data[4] if split_row_data[-1].rstrip() == '매수전': self.kiwoom.send_order(\"send_order_req\", \"0101\", account, 1, code, num, price, hoga_lookup[hoga], \"\") 매도 주문 역시 동일한 방식으로 처리 12345678910# sell listfor row_data in sell_list: split_row_data = row_data.split(';') hoga = split_row_data[2] code = split_row_data[1] num = split_row_data[3] price = split_row_data[4] if split_row_data[-1].rstrip() == '매도전': self.kiwoom.send_order(\"send_order_req\", \"0101\", account, 2, code, num, price, hoga_lookup[hoga], \"\") 매매 주문이 완료되면 buy_list.txt에 저장된 주문 여부를 업데이트. 앞서 매매 주문을 실행했기 때문에 매수전과 매도전을 주문완료로 변경. 123456789# buy listfor i, row_data in enumerate(buy_list): buy_list[i] = buy_list[i].replace(\"매수전\", \"주문완료\")# file updatef = open(\"buy_list.txt\", 'wt')for row_data in buy_list: f.write(row_data)f.close() trade_stocks 전체코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def trade_stocks(self): hoga_lookup = &#123;'지정가': \"00\", '시장가': \"03\"&#125; f = open(\"buy_list.txt\", 'rt') buy_list = f.readlines() f.close() f = open(\"sell_list.txt\", 'rt') sell_list = f.readlines() f.close() # account account = self.comboBox.currentText() # buy list for row_data in buy_list: split_row_data = row_data.split(';') hoga = split_row_data[2] code = split_row_data[1] num = split_row_data[3] price = split_row_data[4] if split_row_data[-1].rstrip() == '매수전': self.kiwoom.send_order(\"send_order_req\", \"0101\", account, 1, code, num, price,hoga_lookup[hoga], \"\") # sell list for row_data in sell_list: split_row_data = row_data.split(';') hoga = split_row_data[2] code = split_row_data[1] num = split_row_data[3] price = split_row_data[4] if split_row_data[-1].rstrip() == '매도전': self.kiwoom.send_order(\"send_order_req\", \"0101\", account, 2, code, num, price,hoga_lookup[hoga], \"\") # buy list for i, row_data in enumerate(buy_list): buy_list[i] = buy_list[i].replace(\"매수전\", \"주문완료\") # file update f = open(\"buy_list.txt\", 'wt') for row_data in buy_list: f.write(row_data) f.close() # sell list for i, row_data in enumerate(sell_list): sell_list[i] = sell_list[i].replace(\"매도전\", \"주문완료\") # file update f = open(\"sell_list.txt\", 'wt') for row_data in sell_list: f.write(row_data) f.close() timeout method123456789101112131415161718def timeout(self): market_start_time = QTime(9, 0, 0) current_time = QTime.currentTime() if current_time &gt; market_start_time and self.trade_stocks_done is False: self.trade_stocks() self.trade_stocks_done = True text_time = current_time.toString(&quot;hh:mm:ss&quot;) time_msg = &quot;현재시간: &quot; + text_time state = self.kiwoom.get_connect_state() if state == 1: state_msg = &quot;서버 연결 중&quot; else: state_msg = &quot;서버 미 연결 중&quot; self.statusbar.showMessage(state_msg + &quot; | &quot; + time_msg) MyWindow 클래스의 생성자에 trade_stocks_done 속성을 추가. 참고로 trade_stocks_done은 생성자에게 Qtimer 객체를 생성하는 코드보다 먼저 위치해야 함. 123456class MyWindow(QMainWindow, form_class): def __init__(self): super().__init__() self.setupUi(self) self.trade_stocks_done = False ¶Link 파이썬으로 배우는 알고리즘 트레이딩","categories":[{"name":"Auto Trading System","slug":"auto-trading-system","permalink":"https://ultrasound.github.io/categories/auto-trading-system/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ultrasound.github.io/tags/python/"},{"name":"kiwoom","slug":"kiwoom","permalink":"https://ultrasound.github.io/tags/kiwoom/"},{"name":"trading","slug":"trading","permalink":"https://ultrasound.github.io/tags/trading/"}]},{"title":"hexo tag plugins test","slug":"hexo-tag-plugins-test","date":"2017-11-12T05:32:33.232Z","updated":"2017-11-12T05:40:32.018Z","comments":true,"path":"2017/11/12/hexo-tag-plugins-test/","link":"","permalink":"https://ultrasound.github.io2017/11/12/hexo-tag-plugins-test/","excerpt":"¶Plain blockquote. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. ¶Quote from a book Do not just seek happiness for yourself. David LevithanWide Awake ¶Quote from Twitter NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 ¶Quote from an article on the web Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing ¶Code Block for loop12for i in abc: print(i) ¶A plain code block 1alert(&apos;Hello World!&apos;); ¶Sepcifying the language 1[rectangle setX: 10 y: 10 width: 20 height: 20]; ¶Adding a caption to the code blcok Array.map1array.map(callback[, thisArg]) ¶Adding a caption and a URL _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] ¶Pull Quote content ¶Post Excerpt Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.","text":"¶Plain blockquote. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. ¶Quote from a book Do not just seek happiness for yourself. David LevithanWide Awake ¶Quote from Twitter NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 ¶Quote from an article on the web Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing ¶Code Block for loop12for i in abc: print(i) ¶A plain code block 1alert(&apos;Hello World!&apos;); ¶Sepcifying the language 1[rectangle setX: 10 y: 10 width: 20 height: 20]; ¶Adding a caption to the code blcok Array.map1array.map(callback[, thisArg]) ¶Adding a caption and a URL _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] ¶Pull Quote content ¶Post Excerpt Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.","categories":[],"tags":[]},{"title":"Test Driven Development with Python","slug":"test-driven-development-with-python","date":"2017-11-10T11:57:00.067Z","updated":"2017-11-10T11:44:09.000Z","comments":true,"path":"2017/11/10/test-driven-development-with-python/","link":"","permalink":"https://ultrasound.github.io2017/11/10/test-driven-development-with-python/","excerpt":"","text":"Testing a Simple Home Page with Unit Tests ¶Unit Tests, and How They Differ from Functional Tests The basic distinction, though, is that functional tests test the application from the outside, from the pont of view of the user. Unit tests test the application from the inside, from the point of view of the programmer. workflow We start by writing a functional test, describing the new functionality from the user’s point of view. Once we have a functional test that fails, we start to think about how to write code that can get it to pass(or at least to get past its current failure). We now use one or more unit tests to define how we want our code to behave - the idea is that each line of production code we write should be tested by (at least) one of our unit tests. Once we have a failing unit test, we write the smallest amount of application code we can, just enough to get the unit test to pass. We may iterate between steps 2 and 3 a few times, until we think the functional test wil get a little further. Now we can rerun our functional tests and see if they pass, or get a littel further. That may prompt us to wirte some new unit tests, and some noe code, and so on. You can see that, all the way through, the functional test are driving what Development we do from a high level, while the unit tests drive what we do at a low level. Note functional tests should help you build an application with the right functionality, and guarantee you never accidentally break it. Unit tests should help you to write code that’s clean and bug free. Django’s workflow An HTTP request comes in for a particular URL. Django uses some rules to decide which view function should deal with the request (this is refereed to as resolving the URL). The view function processes the request and returns an HTTP response. So we want to test two things: Can we resolve the URL for the root of the site (&quot;/&quot;) to a particular view function we’ve made? Can we make this view function return some HTML which will get the functional test to pass? READING TRACEBACKS 123456789101112131415======================================================================ERROR: test_root_url_resolves_to_home_page_view (lists.tests.HomePageTest) 2 ---------------------------------------------------------------------Traceback (most recent call last): File &quot;/.../superlists/lists/tests.py&quot;, line 8, intest_root_url_resolves_to_home_page_view found = resolve(&apos;/&apos;) 3 File &quot;.../django/urls/base.py&quot;, line 27, in resolve return get_resolver(urlconf).resolve(path) File &quot;.../django/urls/resolvers.py&quot;, line 392, in resolve raise Resolver404(&#123;&apos;tried&apos;: tried, &apos;path&apos;: new_path&#125;)django.urls.exceptions.Resolver404: &#123;&apos;tried&apos;: [[&lt;RegexURLResolver 1&lt;RegexURLPattern list&gt; (admin:admin) ^admin/&gt;]], &apos;path&apos;: &apos;&apos;&#125; 1 ---------------------------------------------------------------------[...] The first place you look is usually the error itself. Sometimes that’s all you need to see, and it will let you identify the problem immediately. But sometimes, like in this case, it’s not quite self-evident. The next thing to double-check is: which test is failing? Is it definitely the one we expected - that is, the one we just wrote? In this case, the answer is yes. Then we look for the place in our test code that kicked off the failure. We work our way down form the top of the traceback, looking for the filename of the tests file, to check which test function, and what line of code, the failure is coming from. In thins case it’s the line where we call the resolve function for the “/” URL. Pulling it all together, we interpret the traceback as telling us that, when trying to resolve “/”, Django raised a 404 error - in other words, Django can’t find a URL mapping for “/”. The Unit-Test/Code Cycle We can start to settle into the TDD unit-test/code cycle now: Run the unit tests in the terminal, run the unit tests and see how they fail. Mke a minimal code change in the editor, make a minimal code change to address the current test failure. Repeat!!! What Are We Doing wiht All These Tests?(And, Refactoring) Using Selenium to Test User Interactions ¶NOTE One of the greate things about TDD is that you never have to worry about forgetting what to do next - just rerun your tests and they will tell you what you need to work on. The “Don’t Test Constants” Rule, and Templates to the Rescue In general, one of the rules of unit testing is Don’t test constants, and testing HTML as text is a lot like testing a constant. In other words, if you have some code that says: 1wibble = 3 There’s not much point in a test that says: 12from myprogram import wibbleassert wibble == 3 Unit tests are really about testing logic, flow control, and configuration. Making assertions about exactly what sequence of characters we have in our HTML strings isn’t doing that. What’s more, mangling raw strings in Python really isn’t a great way of dealing with HTML. There’s a much better solution, which is to use templates. Quite apart from anythin else, if we can keep HTML to one side in a file whose name ends in .html, we’ll get better syntax highlighting! There are lots of Python templating frameworks out there and Django has its own which works very well. Refactoring to Use a Template The first rule is that you can’t refactor without tests. On Refactoring TIP When refactoring, work on either the code or the tests, but not both at once. Recap: The TDD Process Functional Tests Unit Tests The unit-test/code Cycle Refactoring We write a test. We run the test and see it fail. We write some minimal code to get it a little further. We rerun the test and repeat until it passes. Then, optionally, we might refactor our code, using tests to make sure we don’t break anything. But how does this apply when we have functional tests and unit tests? Well, you can think of the functional test as being a high-level view of the cycle, where “writing the code” to get the functional tests to pass actually involves using another, smaller TDD cycle which uses unit tests. What about refactoring, in the context of functional tests? Well, that means we use the functional test to check that we’ve preserved the behaviour of our application, but we can change or add and remove unit tests, and use a unit test cycle to acturally change the implementation. The functional tests are the ultimate judge of whether your application works or not. The unit tests are a tool to help you along the way. This way of looking at things is sometimes called “Double-Loop TDD”. one of my eminent tech reviewers, Emily Bache, wrote a blog post on the topic, which I recommend for a different perspective. Saving User Input: Testing the Database When a functional test fails with an unexpected failure, there ara several things we can do to debug it: Add print statements, to show, for example, what the current page text is. Improve the error message to show more info about the current state. Manually visit the site yourself. Use time.sleep to pause the test during execution. Links Obey the Testing Goat! repo","categories":[{"name":"Software Development Process","slug":"software-development-process","permalink":"https://ultrasound.github.io/categories/software-development-process/"},{"name":"Test-Driven Development","slug":"software-development-process/test-driven-development","permalink":"https://ultrasound.github.io/categories/software-development-process/test-driven-development/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ultrasound.github.io/tags/python/"},{"name":"TDD","slug":"tdd","permalink":"https://ultrasound.github.io/tags/tdd/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-10T11:57:00.061Z","updated":"2017-11-10T03:27:51.756Z","comments":true,"path":"2017/11/10/hello-world/","link":"","permalink":"https://ultrasound.github.io2017/11/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ¶Quick Start ¶Create a new post 1$ hexo new \"My New Post\" More info: Writing ¶Run server 1$ hexo server More info: Server ¶Generate static files 1$ hexo generate More info: Generating ¶Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}